---
title: Getting Started with Docker
author: Mateusz512
keywords: tutorial
date: 2019-10-10
layout: tutorial
knotxVersions:
  - 2.0.0
---
## Overview

In this tutorial, we will set up a simple project based on the [Knot.x Starter Kit](https://github.com/Knotx/knotx-starter-kit) template.

We will implement our own custom handler that will print a simple message.

What you’re going to learn:

- How to [define API](https://github.com/Knotx/knotx-server-http#routing-operations) in [Knot.x HTTP Server](https://github.com/Knotx/knotx-server-http) using [Open API specification](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.m)
- How to create a simple Handler and route it to the specific path

## Setup basic Knot.x project

**Prerequisites**
You will need the following things to use Knot.x:
- JDK 8
- Docker 

Download the [Latest Knot.x Starter Kit release](https://github.com/Knotx/knotx-starter-kit/releases) and unzip it.

Project has the following structure:
```
├── docker
|   ├── Dockerfile                // Docker file with image definition.
├── functional                    // Keep here your functional tests. Example implementation included
├── gradle                        // Gradle wrapper and common gradle scripts
├── knotx/conf                    // Knotx configuration which will be copied to docker image
├── modules                       // Sub-modules of your project
│   ├── ...                       // example modules implementation
```

## Create a new routing path

Let's take a look at `knotx/conf/openapi.yaml` file.

It's an [OpenAPI 3.0](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md) specification file that defines the configuration of our project.

We can see three distinguishable parts of this file:

 1.  Information about our project, which is quite self-explanatory:
 
      ```
      ...
      
      openapi: "3.0.0"
      info:
        version: 1.0.0
        title: Knot.x Starter Kit
        description: Knotx Starter Kit
        
      ...
      ```      
 2.  Server configuration that defines how our server behaves:
 
      ```
      ...
      
      servers:
        - url: https://{domain}:{port}
          description: The local API server
          variables:
            domain:
              default: localhost
              description: api domain
            port:
              enum:
                - '8092'
              default: '8092'
      
      ...
      ```
      Here we can see for example that our server will be registered on port `8092`.
 3.  Paths configuration that explicitly specifies our endpoints, their paths, methods, responses and much more in a clear, easily readable and declarative way:
 
      ```
      ...
      
      paths: 
      
        ...   
             
        /healthcheck:
          get:
            operationId: healthcheck-operation
            # https://vertx.io/docs/vertx-health-check/java/
            responses:
              '200':
                description: Everything is fine
              '204':
                description: No procedure are registered.
              '501':
                description: At least one procedure has reported a non-healthy stat
              '500':
                description: One procedure has thrown an error or has not reported a status in time
      ...
      ```
      Our Starter Kit template comes with some already defined paths out of the box. Let's take the `/healthcheck` above as an example. This endpoint serves the purpose of testing whether our dockerized distribution is up and running.
      
      We can see that it is registered under `/healthcheck` path, it's method is a `GET` and it can have various responses depending on the state of the instance.
      
      There's no magic behind it. Healthcheck is handled by operation (more on that later in this tutorial) `healthcheck-operation` implemented as a handler in `HealthcheckHandlerFactory.java`. We will take a look at it later in this tutorial. Just to be brief: it simply calls our example endpoints (defined in `knotx/conf/openapi.yaml` as well). 
      
      This is a nice feature to have! Since we will be using Docker in this tutorial, we will tell docker to check if our instance is up and running by simply calling this endpoint and expecting a response.
      
      Let's take a quick peek at `docker/Dockerfile`:
      
      ```dockerfile
      ... 
      
      HEALTHCHECK --interval=5s --timeout=2s --retries=12 \
        CMD curl --silent --fail localhost:8092/healthcheck || exit 1
        
      ...
      ```
      Quite self-explanatory, isn't it? For more details see [this documentation](https://docs.docker.com/engine/reference/builder/#healthcheck).
      
Now that we know what's going on in this file, let's define our endpoint.

Simply add new routing configuration under `paths`:
```hocon
paths:
  /api/hello:
    get:
      operationId: hello-world-operation
      responses:
        default:
          description: Example API implemented in this tutorial
```

Simple as that! 

Now let's take a closer look at what lies under `operationId: hello-world-operation` ...

## Create a new operation

As you surely noticed, paths have something to do with [operations](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#operationObject). [Routing operations](https://github.com/Knotx/knotx-server-http/tree/master#routing-operations) are defined in `knotx/conf/routes/operations.conf`. 

Let's take a look at this file:

```hocon
routingOperations = ${routingOperations} [
  
  // routing operations for this project
  
]
```

`routingOperations` is an array of `routingOperation` objects. 

`${routingOperations}` takes care of merging any previously defined routing operations with the ones you define here.

Let's take a look at a simple one we have out of the box:
```hocon
  {
    operationId = healthcheck-operation
    handlers = [
      {
        name = healthcheck
      }
    ]
  }
```

Nothing groundbreaking here. We define that for operation `healthcheck-operation` a single [handler](https://vertx.io/docs/apidocs/io/vertx/core/Handler.html) named `healthcheck` will be used.

Let's take a look at a more complicated one:
```hocon
{
    operationId = example-api-with-fragments-operation
    handlers = ${config.server.handlers.common.request} [
      {
        name = singleFragmentSupplier
        config = {
          type = json
          configuration {
            data-knotx-task = api-task
          }
        }
      },
      {
        name = fragmentsHandler
        config = { include required(classpath("routes/handlers/api-with-fragments.conf")) }
      },
      {
        name = fragmentsAssembler
      }
    ] ${config.server.handlers.common.response}
  }
```

Here we provide not one, but three different handlers! Some of them even have some additional configurations defined explicitly or in another file. You'll learn about `fragments` and their power and functionalities in a different tutorial.

Notice two additional imports: `${config.server.handlers.common.request}` and `${config.server.handlers.common.response}`. Here we use the handlers defined in [Knot.x source code](https://github.com/Knotx/knotx-server-http/blob/master/conf/server.conf), which simplifies handling of basic requests without repeating the configuration over and over again for similar operations.

Now that we have a feeling of it, let's connect our `hello-world-operation` with some handler.

Simply add new routing operation to the array:

```hocon
  {
    operationId = hello-world-operation
    handlers = [
      {
        name = hellohandler
      }
    ]
  }
```

## Creating new handler

Almost there!

Now we'll have to provide a handler to handle our request. Let's put it in a separate module.

Create a new module under the `modules` folder. The structure should look like this:

```
modules
└─ hellohandler
    ├── build.gradle.kts                                                        // gradle build script
    └── src 
        └── main                   
            ├── java/com/project/example/healthcheck
            │     └── HelloWorldHandlerFactory.java                             // our handler   
            └── resources
                  └── META-INF/services
                        └── io.knotx.server.api.handler.RoutingHandlerFactory   // META-INF file used by Knot.x to find the handler   
```

Let's take a look at the three files required for our module to work.

`build.gradle.kts`
```kotlin
plugins {
    `java-library`
}

dependencies {

    "io.knotx:knotx".let { v ->
        implementation(platform("$v-dependencies:${project.property("knotx.version")}"))
        api("$v-fragments-api:${project.property("knotx.version")}")
        api("$v-fragments-handler-api:${project.property("knotx.version")}")
    }
    "io.vertx:vertx".let { v ->
        implementation("$v-web")
        implementation("$v-web-client")
        implementation("$v-rx-java2")
    }
}
```

`io.knotx.server.api.handler.RoutingHandlerFactory`
```
io.knotx.example.hellohandler.HelloWorldHandlerFactory
```

In this file we list, line by line, all the RoutingHandlerFactory implementations we want Knot.x to see. It has to be full class identifier.

`HelloWorldHandlerFactory.java`
```
package io.knotx.example.hellohandler;

import io.knotx.server.api.handler.RoutingHandlerFactory;
import io.vertx.core.Handler;
import io.vertx.core.json.JsonObject;
import io.vertx.reactivex.core.Vertx;
import io.vertx.reactivex.ext.web.RoutingContext;

public class HelloWorldHandlerFactory implements RoutingHandlerFactory {

  @Override
  public String getName() {
    return "hellohandler";    // this has to be exactly the same string as in operations.conf file                                                 
  }

  @Override
  public Handler<RoutingContext> create(Vertx vertx, JsonObject config) {
    JsonObject jsonObject = new JsonObject()
        .put("message", "Hello World From Knot.x!");
    return event -> event.response().end(jsonObject.toString());
  }
}
```

And there is our handler!

The most important thing is to register it by its name. In our case, it was `"hellohandler"`. 

The handling it performs is simply ending the response with our *Hello World from Knot.x!* JSON.

Now we're ready to launch!

## Docker

### Configuration
[Knot.x Starter Kit](https://github.com/Knotx/knotx-starter-kit) project builds either stack (zip distribution) or docker image. In this tutorial, we'll use the latter.
 
 Let's rename our image. Edit `gradle.properties` and change property `docker.image.name`:

```
docker.image.name=knotx-example/knotx-docker-tutorial
```

### Run

Now we are ready to run. First, let's build your docker image:
```
$ gradlew clean build-docker
```

If you take a closer look at build log (you can use `-i` flag for a more verbose process) you can see, that not only our project is being built, but also it:

- builds the docker image
- starts a container for testing
- runs healthcheck test on the container
- runs functional tests

Now let's run our Knot.x instance:
```
$ docker run -p8092:8092 knotx-example/knotx-docker-tutorial
```

## Final result

```
$ curl -X GET http://localhost:8092/api/hello
{"message":"Hello World From Knot.x!"}
```

### Tests

Now let's take a closer look at what tests we have here.

The first, mentioned before is the `healthcheck`. Technically speaking, this is not a *test*, but rather an endpoint in which, we call our own endpoints within our application. If the request succeeds, we can be sure that our Docker container is up and running. We execute that call in `Dockerfile`, as described in the *Create a new routing path* section.
 
 We'll modify it so that it will use our `/api/hello` endpoint. 

Simply change the `create` method:
```java
public Handler<RoutingContext> create(Vertx vertx, JsonObject config) {
    HealthChecks checks = HealthChecks.create(vertx);
    checks.register("API check", 200, future -> {
      WebClient webClient = WebClient.create(vertx);
      webClient.get(8092, "localhost", "/api/hello")
          .rxSend()
          .subscribe(onSuccess -> {
            JsonObject jsonResponse = onSuccess.bodyAsJsonObject();
            future.complete("Hello World From Knot.x!".equals(jsonResponse.getString("message")) ? Status.OK() : Status.KO());
          }, onError -> future
              .complete(Status.KO(new JsonObject().put("error", onError.getMessage()))));
});
```

We also have integration tests on board!

As this line suggests: 

`build.gradle.kts`
```kotlin
sourceSets.named("test") {
    java.srcDir("functional/src/test/java")
}
```

They can be found under `functional/src/test/java`. 

For now, we have one test that comes out of the box with the Starter Kit: `ExampleApiITCase`. Let's change it as well. 

Again, we'll modify the test to use our `/api/hello` endpoint:

```java
  @Test
  @DisplayName("Expect 200 status code from hello api.")
  void callHandlersApiEndpointAndExpectOK() {
    // @formatter:off
    given().
        port(8092).
      when().
        get("/api/hello").
      then()
        .assertThat().
        statusCode(200);
    // @formatter:on
  }
```

So what exactly is going on here?

If you look closely at [this file](https://raw.githubusercontent.com/Knotx/knotx-starter-kit/master/gradle/docker.gradle.kts), you can see that task `runFunctionalTests` relies on docker container to be up (which is ensured by `healthcheck`). Now that we have our application running, we can run integration tests by invoking any endpoints you want and asserting their responses. Here we use [REST-assured](http://rest-assured.io/) for this purpose.



---

You can find full project implementation [here](https://github.com/Knotx/knotx-example-project/tree/master/distribution/docker).
